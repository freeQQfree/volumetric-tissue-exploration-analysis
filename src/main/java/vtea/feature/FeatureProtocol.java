/* 
 * Copyright (C) 2016 Indiana University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package vtea.feature;


import vtea.protocol.listeners.AnalysisStartListener;
import vtea.protocol.listeners.DeleteBlockListener;
import vtea.protocol.listeners.MicroBlockSetupListener;
import vtea.protocol.listeners.RebuildPanelListener;
import vtea.protocol.listeners.RequestImageListener;
import vtea.protocol.setup.MicroBlockObjectSetup;
import vtea.protocol.blockstepgui.FeatureStepBlockGUI;
import vtea.protocol.listeners.UpdateProgressListener;
import vtea.protocol.listeners.UpdateSegmentationListener;
import vtea.protocol.listeners.UpdatedProtocolListener;
import ij.ImagePlus;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.util.ArrayList;
import java.util.ListIterator;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JWindow;
import vtea.protocol.listeners.UpdatedImageListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
/**
 *
 * @author vinfrais
 */
public class FeatureProtocol extends javax.swing.JPanel implements PropertyChangeListener, UpdateProgressListener/*, ImageSelectionListener*/, RebuildPanelListener, DeleteBlockListener {

//    private ImagePlus OriginalImage;
//    private ImagePlus ProcessedImage;
//    private ImagePlus ThumbnailImage;
//    protected JPanel thumbnail;

//    protected Color ImageBlockBackground = new java.awt.Color(135, 175, 215);

    protected ArrayList<FeatureStepBlockGUI> FeatureStepsList;
    

    //public JWindow thumb = new JWindow();

    protected GridLayout FeatureLayout = new GridLayout(4, 1, 0, 0);

//    protected ArrayList<String> Channels;

//    private ArrayList<AnalysisStartListener> listeners = new ArrayList<AnalysisStartListener>();
//    private ArrayList<RequestImageListener> RequestImageListeners = new ArrayList<RequestImageListener>();
//    //private ArrayList<RepaintTabListener> RepaintTabListeners = new ArrayList<RepaintTabListener>();
//    
//    private ArrayList<UpdatedImageListener> UpdatedImageListeners = new ArrayList<UpdatedImageListener>();   
//    private ArrayList<UpdatedProtocolListener> UpdatedProtocolListeners = new ArrayList<UpdatedProtocolListener>();
    
    //private final MicroExperiment me = new MicroExperiment();

    /**
     * Creates new form NewJPanel
     */
    public FeatureProtocol() {
        this.FeatureStepsList = new ArrayList<FeatureStepBlockGUI>();
        initComponents();   
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        FeatureAnalysis = new javax.swing.JPanel();
        Feature_Header = new javax.swing.JPanel();
        AnalyzeDataText = new javax.swing.JLabel();
        FeatureLabel = new javax.swing.JLabel();
        AddStep = new javax.swing.JButton();
        DeleteAllSteps = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        exploreText = new javax.swing.JLabel();
        Feature_Panel = new javax.swing.JPanel();
        FeatureStepsPanel = new javax.swing.JPanel();
        FeatureGo = new javax.swing.JButton();
        ProgressPanel = new javax.swing.JPanel();
        ProgressComment = new javax.swing.JLabel();
        VTEAProgressBar = new javax.swing.JProgressBar();

        setMaximumSize(new java.awt.Dimension(445, 381));
        setMinimumSize(new java.awt.Dimension(445, 381));
        setPreferredSize(new java.awt.Dimension(445, 381));
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });
        java.awt.FlowLayout flowLayout1 = new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, 1, 1);
        flowLayout1.setAlignOnBaseline(true);
        setLayout(flowLayout1);

        FeatureAnalysis.setMaximumSize(new java.awt.Dimension(750, 353));
        FeatureAnalysis.setMinimumSize(new java.awt.Dimension(750, 353));
        FeatureAnalysis.setLayout(new java.awt.GridBagLayout());

        Feature_Header.setBackground(new java.awt.Color(204, 204, 204));
        Feature_Header.setForeground(new java.awt.Color(102, 102, 102));
        Feature_Header.setAlignmentX(0.0F);
        Feature_Header.setAlignmentY(0.0F);
        Feature_Header.setMaximumSize(new java.awt.Dimension(440, 36));
        Feature_Header.setMinimumSize(new java.awt.Dimension(440, 36));
        Feature_Header.setPreferredSize(new java.awt.Dimension(440, 36));
        Feature_Header.setLayout(new java.awt.GridBagLayout());

        AnalyzeDataText.setText("Analyze Data...");
        AnalyzeDataText.setMaximumSize(new java.awt.Dimension(120, 16));
        AnalyzeDataText.setMinimumSize(new java.awt.Dimension(100, 16));
        AnalyzeDataText.setPreferredSize(new java.awt.Dimension(100, 16));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        Feature_Header.add(AnalyzeDataText, gridBagConstraints);

        FeatureLabel.setBackground(new java.awt.Color(0, 0, 0));
        FeatureLabel.setFont(new java.awt.Font("Helvetica Neue", 0, 24)); // NOI18N
        FeatureLabel.setText("Feature");
        FeatureLabel.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        FeatureLabel.setMaximumSize(new java.awt.Dimension(150, 28));
        FeatureLabel.setMinimumSize(new java.awt.Dimension(150, 28));
        FeatureLabel.setPreferredSize(new java.awt.Dimension(90, 28));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        Feature_Header.add(FeatureLabel, gridBagConstraints);

        AddStep.setBackground(new java.awt.Color(204, 204, 204));
        AddStep.setForeground(new java.awt.Color(102, 102, 102));
        AddStep.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/list-add-3 2.png"))); // NOI18N
        AddStep.setToolTipText("Add an analysis method.");
        AddStep.setMaximumSize(new java.awt.Dimension(34, 34));
        AddStep.setMinimumSize(new java.awt.Dimension(34, 34));
        AddStep.setPreferredSize(new java.awt.Dimension(34, 34));
        AddStep.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AddStepActionPerformed(evt);
            }
        });
        Feature_Header.add(AddStep, new java.awt.GridBagConstraints());

        DeleteAllSteps.setBackground(new java.awt.Color(204, 204, 204));
        DeleteAllSteps.setForeground(new java.awt.Color(102, 102, 102));
        DeleteAllSteps.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/edit-clear-list_24.png"))); // NOI18N
        DeleteAllSteps.setToolTipText("Delete all analysis methods.");
        DeleteAllSteps.setEnabled(false);
        DeleteAllSteps.setMaximumSize(new java.awt.Dimension(34, 34));
        DeleteAllSteps.setMinimumSize(new java.awt.Dimension(34, 34));
        DeleteAllSteps.setPreferredSize(new java.awt.Dimension(34, 34));
        DeleteAllSteps.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DeleteAllStepsActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        Feature_Header.add(DeleteAllSteps, gridBagConstraints);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        Feature_Header.add(jPanel1, new java.awt.GridBagConstraints());

        exploreText.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        exploreText.setForeground(new java.awt.Color(153, 153, 153));
        exploreText.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        exploreText.setText("...explore");
        exploreText.setVerticalAlignment(javax.swing.SwingConstants.BOTTOM);
        exploreText.setPreferredSize(new java.awt.Dimension(85, 40));
        exploreText.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        Feature_Header.add(exploreText, new java.awt.GridBagConstraints());

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.ipady = 7;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 0);
        FeatureAnalysis.add(Feature_Header, gridBagConstraints);

        Feature_Panel.setBackground(new java.awt.Color(204, 204, 204));
        Feature_Panel.setForeground(new java.awt.Color(102, 102, 102));
        Feature_Panel.setAlignmentX(0.0F);
        Feature_Panel.setAlignmentY(0.0F);
        Feature_Panel.setMaximumSize(new java.awt.Dimension(440, 360));
        Feature_Panel.setMinimumSize(new java.awt.Dimension(440, 360));
        Feature_Panel.setPreferredSize(new java.awt.Dimension(440, 300));
        Feature_Panel.setRequestFocusEnabled(false);

        FeatureStepsPanel.setBackground(vtea._vtea.ACTIONPANELBACKGROUND);
        FeatureStepsPanel.setPreferredSize(new java.awt.Dimension(160, 245));

        javax.swing.GroupLayout FeatureStepsPanelLayout = new javax.swing.GroupLayout(FeatureStepsPanel);
        FeatureStepsPanel.setLayout(FeatureStepsPanelLayout);
        FeatureStepsPanelLayout.setHorizontalGroup(
            FeatureStepsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 360, Short.MAX_VALUE)
        );
        FeatureStepsPanelLayout.setVerticalGroup(
            FeatureStepsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 245, Short.MAX_VALUE)
        );

        FeatureGo.setBackground(vtea._vtea.BUTTONBACKGROUND);
        FeatureGo.setText("Find Features");
        FeatureGo.setToolTipText("Find segmented objects.");
        FeatureGo.setEnabled(false);
        FeatureGo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FeatureGoActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout Feature_PanelLayout = new javax.swing.GroupLayout(Feature_Panel);
        Feature_Panel.setLayout(Feature_PanelLayout);
        Feature_PanelLayout.setHorizontalGroup(
            Feature_PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Feature_PanelLayout.createSequentialGroup()
                .addGroup(Feature_PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(Feature_PanelLayout.createSequentialGroup()
                        .addGap(44, 44, 44)
                        .addComponent(FeatureGo, javax.swing.GroupLayout.PREFERRED_SIZE, 112, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(Feature_PanelLayout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addComponent(FeatureStepsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 360, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(44, Short.MAX_VALUE))
        );
        Feature_PanelLayout.setVerticalGroup(
            Feature_PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Feature_PanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(FeatureStepsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(FeatureGo)
                .addContainerGap(68, Short.MAX_VALUE))
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 5, 0);
        FeatureAnalysis.add(Feature_Panel, gridBagConstraints);

        add(FeatureAnalysis);

        ProgressPanel.setMaximumSize(new java.awt.Dimension(445, 50));
        ProgressPanel.setMinimumSize(new java.awt.Dimension(445, 50));
        ProgressPanel.setPreferredSize(new java.awt.Dimension(445, 30));
        ProgressPanel.setRequestFocusEnabled(false);
        java.awt.FlowLayout flowLayout2 = new java.awt.FlowLayout(java.awt.FlowLayout.TRAILING, 1, 1);
        flowLayout2.setAlignOnBaseline(true);
        ProgressPanel.setLayout(flowLayout2);

        ProgressComment.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        ProgressPanel.add(ProgressComment);

        VTEAProgressBar.setPreferredSize(new java.awt.Dimension(200, 20));
        ProgressPanel.add(VTEAProgressBar);

        add(ProgressPanel);
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
       
    }//GEN-LAST:event_formKeyPressed

    private void FeatureGoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FeatureGoActionPerformed

        new Thread(new Runnable() {
            public void run() {
                VTEAProgressBar.setIndeterminate(true);
                FeatureGo.setEnabled(false);
                //PreProcessingGo.setEnabled(false);
                //executeObjectFinding();
                //ObjectGo.setEnabled(true);
                //PreProcessingGo.setEnabled(true);
                VTEAProgressBar.setIndeterminate(false);
                // Runs inside of the Swing UI thread
                //          SwingUtilities.invokeLater(new Runnable() {
                    //            public void run() {
                        //                for(int i = 0; i < 100; i++){
                            //
                            //              ObjectProcess.setValue(i);
                            //                ObjectProcess.updateUI();}
                        //            }
                    //          });

            try {
                java.lang.Thread.sleep(100);
            }
            catch(Exception e) { }
        }
        }).start();
    }//GEN-LAST:event_FeatureGoActionPerformed

    private void DeleteAllStepsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DeleteAllStepsActionPerformed
        FeatureStepsList.clear();
        FeatureStepsPanel.removeAll();
        AddStep.setEnabled(true);
        DeleteAllSteps.setEnabled(false);
        FeatureStepsPanel.repaint();
        //pack();
    }//GEN-LAST:event_DeleteAllStepsActionPerformed

    private void AddStepActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AddStepActionPerformed
        FeatureStepBlockGUI block = new FeatureStepBlockGUI("Feature Step", "", Color.LIGHT_GRAY,FeatureStepsList.size() + 1);
        block.addDeleteBlockListener(this);
        block.addRebuildPanelListener(this);
        //this.notifyRepaintFeatureListeners();

        FeatureStepsPanel.setLayout(FeatureLayout);
        FeatureStepsPanel.add(block.getPanel());
        FeatureStepsPanel.repaint();
        //this.repaint();
        this.getParent().repaint();
        FeatureStepsList.add(block);

        if (FeatureStepsList.size() <= 2) {
            AddStep.setEnabled(true);
        }
        if (FeatureStepsList.size() >= 3) {
            AddStep.setEnabled(false);
        }
        if (!FeatureStepsList.isEmpty()){
            DeleteAllSteps.setEnabled(true);
        }
            
        
        
    }//GEN-LAST:event_AddStepActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton AddStep;
    private javax.swing.JLabel AnalyzeDataText;
    private javax.swing.JButton DeleteAllSteps;
    private javax.swing.JPanel FeatureAnalysis;
    private javax.swing.JButton FeatureGo;
    private javax.swing.JLabel FeatureLabel;
    private javax.swing.JPanel FeatureStepsPanel;
    private javax.swing.JPanel Feature_Header;
    private javax.swing.JPanel Feature_Panel;
    public javax.swing.JLabel ProgressComment;
    private javax.swing.JPanel ProgressPanel;
    public javax.swing.JProgressBar VTEAProgressBar;
    private javax.swing.JLabel exploreText;
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables

/*
    //classes for batch processing
    public void setTabValue(int tab) {
        this.tab = tab;
    }

    public void setTabName(String st) {
        this.tabName = st;
    }
*/
    @Override
    public void rebuildPanel(int type) {
        this.RebuildPanelFeature();
    }

    @Override
    public void deleteBlock(int type, int position) {
        this.deleteFeatureStep(position);
    }

    @Override
    public void changeProgress(String text, int min, int max, int position) {      
        VTEAProgressBar.setMinimum(min);
        VTEAProgressBar.setMaximum(max);
        VTEAProgressBar.setValue(position);
        ProgressComment.setText(text);    
    }

/*    @Override
    public int onFileOpen() throws Exception {
        if(this.selected){
                System.out.println("PROFILING: Opening settings for tab: " + this.tab);
		JFileChooser chooser = new JFileChooser();
		FileNameExtensionFilter filter = new FileNameExtensionFilter("VTEA file.", ".vtf", "vtf");
                chooser.addChoosableFileFilter(filter);
		chooser.setFileFilter(filter);
		int returnVal = chooser.showOpenDialog(this);	
		if(returnVal == JFileChooser.APPROVE_OPTION){
                    
                    
                        System.out.println("PROFILING: Opening settings...");
                    
			File file = chooser.getSelectedFile();
			FileInputStream fis = new FileInputStream(file);
			ObjectInputStream ois = new ObjectInputStream(fis);
			Object temp = ois.readObject();
                        
                        //Add logic here for file type loading...
                        
			FeatureStepBlockGUI image = FeatureStepsList.get(0);
                        FeatureStepsList.clear();
                        FeatureStepsList.add(image);
                        
                        //Extract returns ArrayList of arraylists...  make new ProcessingBlockGUIs by arraylist.
			ListIterator<ArrayList> itr = ((ArrayList<ArrayList>)temp).listIterator();  
                        
                        while(itr.hasNext()){
                            FeatureStepBlockGUI ppsb = new FeatureStepBlockGUI("Feature", "", Color.LIGHT_GRAY, false, ThumbnailImage, OriginalImage, Channels, ProtocolManagerMulti.PROCESS, FeatureStepsList, FeatureStepsList.size() + 1);
                            ppsb.onChangeSetup(itr.next());    
                        }
                        
                        this.RebuildPanelFeature();
                        
			repaint();
			ois.close();
                        
			return 1;
		}else{
			repaint();
			
			return -1;
		}
        }  
        
        return -1;
    }

    @Override
    public void onFileSave() throws Exception {
        if(this.selected){
            System.out.println("PROFILING: Saving settings...");
            JFileChooser chooser = new JFileChooser();
            FileNameExtensionFilter filter = new FileNameExtensionFilter("VTEA file.", ".vtf", "vtf");
            chooser.setFileFilter(filter);          
	    chooser.showSaveDialog(this);
	    File file = chooser.getSelectedFile();
            
            String filename = file.getName();
            if (!filename.endsWith(".vtf")){
                String path = file.getPath();
                path += ".vtf"; 
                file = new File(path);
            }
            
	    FileOutputStream fos = new FileOutputStream(file);
	    ObjectOutputStream oos = new ObjectOutputStream(fos);
	    oos.writeObject(extractSteps(this.FeatureStepsList));
	    oos.close();
	    repaint();
        }   
    }

    @Override
    public void onFileExport() throws Exception {
        
    }
*/
/*
    @Override
    public void onUpdateSegmentation(int i) {
        if(me.ExploreDrawer.size() > 0){
          me.emptyExplorerDrawer();
          me.emptyFolderDrawer();
          
          FeatureGo.setText("Update");
        }
        FeatureGo.setEnabled(true);
    }
*/
    @Override
    public void propertyChange(PropertyChangeEvent evt) {

        if (evt.getPropertyName().equals("progress")) {
            int progress = (Integer) evt.getNewValue();
            VTEAProgressBar.setValue(progress);
            ProgressComment.setText(String.format(
                    "Completed %d%%...\n", progress));
        } 
        if (evt.getPropertyName().equals("comment")){
            ProgressComment.setText((String)evt.getNewValue());
        }
        if (evt.getPropertyName().equals("escape") && (Boolean)evt.getNewValue()){
            
            ImagePlus ProcessedShow = new ImagePlus("Processed");
            //ProcessedShow = UtilityMethods.makeThumbnail(ProcessedImage);
            ProcessedShow.setTitle(this.getName() + "_Processed");

            ProgressComment.setText("Processing complete...");
            ProcessedShow.show();
            

            /*
            if(ObjectStepsList.size() > 0){
                me.FolderDrawer.clear(); 
                me.ExploreDrawer.clear(); 
                notifyUpdatedImageListeners(ProcessedImage); 
            }
            */
        }
        if ("escape" == evt.getPropertyName() && !(Boolean)evt.getNewValue()){
           
            
         System.out.println("PROFILING: Error is processing, thread terminated early...");
           
    }
    }
    


 

//classes for step blocks
    private final class ObjectStepBlockGUI extends Object implements MicroBlockSetupListener, UpdatedImageListener, UpdatedProtocolListener {

        JPanel step = new JPanel();
        Font PositionFont = new Font("Arial", Font.PLAIN, 14);
        Font ObjectFont = new Font("Arial", Font.BOLD, 12);
        Font CommentFont = new Font("Arial", Font.ITALIC, 10);
        JLabel Position = new JLabel();
        JLabel Comment = new JLabel("Block by Block");
        JLabel Object = new JLabel("First things first");
        boolean ProcessTypeSet = false;
        boolean thresholdPreviewRoi = false;
        int position;
        
        JButton DeleteButton;
        JButton EditButton;
        JButton MeasureButton;
        JButton UpdateExplorer;

        MicroBlockObjectSetup mbs;

        private ArrayList settings;
        
        private ArrayList<UpdateSegmentationListener> UpdateSegmentationListeners = new ArrayList<UpdateSegmentationListener>();

        public ObjectStepBlockGUI() {
            BuildStepBlock("Setup segmentation...", "", Color.LIGHT_GRAY);
        }

        public ObjectStepBlockGUI(String ProcessText, String CommentText, Color BlockColor) {
            BuildStepBlock(ProcessText, CommentText, Color.GREEN);
        }

        private void BuildStepBlock(String ProcessText, String CommentText, Color BlockColor) {

            if (FeatureStepsList.isEmpty()) {
                position = 1;
            } else {
                position = FeatureStepsList.size() + 1;
            }

            Object.setText(ProcessText);

            Comment.setText(CommentText);
            step.setBackground(BlockColor);

            //need max size set here
            Position.setText(position + ".");
            Position.setFont(PositionFont);

            if (Object.getText().length() < 12) {
                ObjectFont = new Font("Arial", Font.BOLD, 10);
            }
            if (Comment.getText().length() > 12) {
                CommentFont = new Font("Arial", Font.BOLD, 8);
            }

            Object.setFont(ObjectFont);
            Comment.setFont(CommentFont);

            mbs = new MicroBlockObjectSetup(position, Channels, ProcessedImage);
            
            
            mbs.setVisible(false);
            mbs.addMicroBlockSetupListener(this);

            DeleteButton = new JButton();
            DeleteButton.setPreferredSize(new Dimension(20, 20));
            DeleteButton.addActionListener(new java.awt.event.ActionListener() {
                @Override
                public void actionPerformed(ActionEvent ae) {
                    deleteFeatureStep(position);
                }
            });

            EditButton = new JButton();
            EditButton.setPreferredSize(new Dimension(20, 20));
            EditButton.addActionListener(new java.awt.event.ActionListener() {
                @Override
                public void actionPerformed(ActionEvent ae) {
                    mbs.setVisible(true);
                    
                }
            });
            
            MeasureButton = new JButton();
            MeasureButton.setPreferredSize(new Dimension(20, 20));
            MeasureButton.addActionListener(new java.awt.event.ActionListener() {
                @Override
                public void actionPerformed(ActionEvent ae) {
                    //mbs.setVisible(true);
                    
                }
            });
            MeasureButton.setEnabled(false);
            
            UpdateExplorer = new JButton();
            UpdateExplorer.addActionListener(new java.awt.event.ActionListener() {
                @Override
                public void actionPerformed(ActionEvent ae) {
                    notifyUpdateSegmentationListeners(position); 
                }
            });
            UpdateExplorer.setEnabled(false);
            

            DeleteButton.setSize(20, 20);
            DeleteButton.setBackground(vtea._vtea.BUTTONBACKGROUND);
            DeleteButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/edit-delete-6_16.png")));
            DeleteButton.setToolTipText("Delete protocol...");

            EditButton.setSize(20, 20);
            EditButton.setBackground(vtea._vtea.BUTTONBACKGROUND);
            EditButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/edit-4.png")));
            EditButton.setToolTipText("Edit segmentation protocol...");
            
            MeasureButton.setSize(20, 20);
            MeasureButton.setBackground(vtea._vtea.BUTTONBACKGROUND);
            MeasureButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/ruler.png")));
            MeasureButton.setToolTipText("Edit measurements...");
            
            UpdateExplorer.setSize(20, 20);
            UpdateExplorer.setBackground(vtea._vtea.BUTTONBACKGROUND);
            UpdateExplorer.setText("UPDATE");
            UpdateExplorer.setToolTipText("UPDATE");
            
            JPanel fill = new JPanel();
            fill.setPreferredSize(new Dimension(20,20));

            step.setSize(205, 20); 
            step.setBorder(javax.swing.BorderFactory.createEtchedBorder());

            step.setLayout(new GridBagLayout());
            GridBagConstraints layoutConstraints = new GridBagConstraints();

//            layoutConstraints.fill = GridBagConstraints.BOTH;
//            layoutConstraints.gridx = 0;
//            layoutConstraints.gridy = 0;
//            layoutConstraints.weightx = 1;
//            layoutConstraints.weighty = 1;
//            step.add(UpdateExplorer, layoutConstraints);

            layoutConstraints.fill = GridBagConstraints.BOTH;
            layoutConstraints.gridx = 1;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 10;
            layoutConstraints.weighty = 10;
            step.add(Object, layoutConstraints);

            layoutConstraints.fill = GridBagConstraints.BOTH;
            layoutConstraints.gridx = 1;
            layoutConstraints.gridy = 1;
            layoutConstraints.weightx = 10;
            layoutConstraints.weighty = 10;
            step.add(Comment, layoutConstraints);
            
//            layoutConstraints.fill = GridBagConstraints.BOTH;
//            layoutConstraints.gridx = 2;
//            layoutConstraints.gridy = 0;
//            layoutConstraints.weightx = -1;
//            layoutConstraints.weighty = -1;
//            layoutConstraints.ipadx = -1;
//            layoutConstraints.ipady = -1;
//            step.add(UpdateExplorer, layoutConstraints);

            layoutConstraints.fill = GridBagConstraints.BOTH;
            layoutConstraints.gridx = 2;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = -1;
            layoutConstraints.weighty = -1;
            layoutConstraints.ipadx = 0;
            layoutConstraints.ipady = 20;
            step.add(DeleteButton, layoutConstraints);

            layoutConstraints.fill = GridBagConstraints.BOTH;
            layoutConstraints.gridx = 2;
            layoutConstraints.gridy = 1;
            layoutConstraints.weightx = -1;
            layoutConstraints.weighty = -1;
            layoutConstraints.ipadx = 0;
            layoutConstraints.ipady = 20;
            step.add(EditButton, layoutConstraints);
            
            layoutConstraints.fill = GridBagConstraints.BOTH;
            layoutConstraints.gridx = 2;
            layoutConstraints.gridy = 2;
            layoutConstraints.weightx = -1;
            layoutConstraints.weighty = -1;
            layoutConstraints.ipadx = 0;
            layoutConstraints.ipady = 20;
            step.add(MeasureButton, layoutConstraints);
            
            layoutConstraints.fill = GridBagConstraints.BOTH;
            layoutConstraints.gridx = 1;
            layoutConstraints.gridy = 2;
            layoutConstraints.weightx = -1;
            layoutConstraints.weighty = -1;
            layoutConstraints.ipadx = 0;
            layoutConstraints.ipady = 20;
           
            step.add(fill, layoutConstraints);

            step.addMouseListener(new java.awt.event.MouseListener() {
                @Override
                public void mouseEntered(java.awt.event.MouseEvent evt) {
                }

                ;
            @Override
                public void mouseExited(java.awt.event.MouseEvent evt) {
                    //thumb.setVisible(false);
                }

                ;
            @Override
                public void mouseReleased(java.awt.event.MouseEvent evt) {
                    //thumb.setVisible(false);
                }

                ;
            @Override
                public void mousePressed(java.awt.event.MouseEvent evt) {

                }

                ;
            @Override
                public void mouseClicked(java.awt.event.MouseEvent evt) {
                }
            ;
        }

        );
        }
        
    public void addUpdateSegmentationListener(UpdateSegmentationListener listener) {
        UpdateSegmentationListeners.add(listener);
    }

    private void notifyUpdateSegmentationListeners(int tab) {
        for (UpdateSegmentationListener listener : UpdateSegmentationListeners) {
            listener.onUpdateSegmentation(tab);
        }
    }

    public void setPosition(int n) {
        position = n;
        Position.setText(position + ".");
    }

    public JPanel getPanel() {
        return step;
    }

    public int getPosition() {
        return position;
    }

    public ArrayList getVariables() {
        return settings;
    }

        @Override
        public void onChangeSetup(ArrayList al2) {

            ArrayList al = new ArrayList();
            ArrayList al_key = new ArrayList();

            al = (ArrayList) al2.get(0);
            al_key = (ArrayList) al.get(2);

            String MethodText = new String();

            MethodText = " " + al_key.get(0).toString() + ": " + al.get(3).toString() + " " + al_key.get(2).toString() + ": " + al.get(5).toString() + " " + al_key.get(3).toString() + ": " + al.get(6).toString();

            Object.setText("Object_" +getPosition()+ ": " + al.get(1) + ", by: " + Channels.get((Integer) al.get(0)).toString());
            Comment.setText(MethodText);
            
            RebuildPanelFeature();
            this.settings = al2;
            notifyUpdateSegmentationListeners(1);
        }

        @Override
        public void onUpdateImage(ImagePlus imp) {
           this.mbs.setProcessedImage(imp);
           this.mbs.updateNewImage();
        }

        @Override
        public void protocolUpdated(ArrayList<ArrayList> al) {
        }

    }

    
    //GUI table manipulation
    private void deleteFeatureStep(int position) {

        //System.out.println("PROFILING: Process position: " + position);
        //remove from PreProcessingStepsList
        FeatureStepsList.remove(position - 1);
        UpdatePositionFeature(position); 
        FeatureStepsList.trimToSize();
        
        //System.out.println("PROFILING: Processlist length: " + ProcessingStepsList.size());
        
        FeatureStepsPanel.removeAll();
        FeatureStepsPanel.setLayout(FeatureLayout);
        
        

        if (FeatureStepsList.size() < 0) {
        } else {
            RebuildPanelFeature();
        }

        if (FeatureStepsList.size() < 5) {
            AddStep.setEnabled(true);
        }
        if(FeatureStepsList.isEmpty()){
            DeleteAllSteps.setEnabled(false);
        }

        FeatureStepsPanel.repaint();
        //this.notifyRepaintTabListeners();
        //pack();

    }

/*    private void deleteObjectStep(int position) {

        ObjectStepsList.remove(position - 1);
        UpdatePositionObject(position);
        ObjectStepsList.trimToSize();
        

        
        ObjectStepsPanel.removeAll();
        ObjectStepsPanel.setLayout(ObjectLayout);
        
        
        if (ObjectStepsList.size() < 0) {
        } else {
            RebuildPanelObject();
        }
        if (5 >= ObjectStepsList.size()) {
            AddStep_Object.setEnabled(true);
        }

        ObjectStepsPanel.repaint();
        this.notifyRepaintTabListeners();
    }
*/
/*
    public ArrayList getFeatureSteps() {

        ArrayList<FeatureStepBlockGUI> export = new ArrayList<FeatureStepBlockGUI>();

        for(int i = 1; i < FeatureStepsList.size(); i++) {
            try {
                FeatureStepBlockGUI psbg = (FeatureStepBlockGUI)FeatureStepsList.get(i).clone();
                export.add(psbg);
            } catch (CloneNotSupportedException ex) {
                Logger.getLogger(ImageFeatureProtocol.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return export;
    }
*/
    public ArrayList getFeatureSteps() {
        return this.FeatureStepsList;
    }

    public ArrayList getProProcessingProtocol() {
        return extractSteps(FeatureStepsList);
    }
    
    public ArrayList getProcessingProtocolList() {
        return this.FeatureStepsList;
    }

    public void setProcessSteps(ArrayList FeatureStepsList) {
        FeatureStepsList.trimToSize();
        this.FeatureStepsList.addAll(FeatureStepsList);
        UpdatePositionFeature(0);
        this.RebuildPanelFeature();
    }

/*    public void setObjectSteps(ArrayList ObjectStepList) {
        this.ObjectStepsList = ObjectStepList;
        this.RebuildPanelObject();
    }
  */
/*
    public ImagePlus getOriginalImage(){
        return this.OriginalImage;
    }
    
      public ImagePlus getThumbnailImage(){
        return this.ThumbnailImage;
    }
*/
    public void RebuildPanelFeature() {
        FeatureStepBlockGUI sb;
        ListIterator litr = FeatureStepsList.listIterator();
        while (litr.hasNext()) {
            sb = (FeatureStepBlockGUI) litr.next();
            sb.setPosition(FeatureStepsList.indexOf(sb) + 1);
            FeatureStepsPanel.add(sb.getPanel());   
        }
    }
/*
    public void RebuildPanelObject() {
        ObjectStepBlockGUI sb;
        ListIterator litr = ObjectStepsList.listIterator();
        while (litr.hasNext()) {
            sb = (ObjectStepBlockGUI) litr.next();
            sb.setPosition(ObjectStepsList.indexOf(sb) + 1);
            ObjectStepsPanel.add(sb.getPanel());
        }
    }
*/
    public void UpdatePositionFeature(int position) {
        FeatureStepBlockGUI sb;
            for (int i = 1; i < FeatureStepsList.size(); i++) {
                sb = (FeatureStepBlockGUI) FeatureStepsList.get(i);
                sb.setPosition(i);
                FeatureStepsList.set(i, sb);
            }
    }

    private void executeFeatures() {
        
        ProgressComment.setText("Finding Features...");

        ArrayList<ArrayList> protocol = new ArrayList<>();

        //get the arraylist, decide the nubmer of steps, by .steps to do and whether this is a preview or final by .type
        
        protocol = extractSteps(FeatureStepsList);
        
        ProgressComment.setText("Processing image data...");

        /*if(protocol.size() > 0){
        
            ProcessedImage = OriginalImage.duplicate();
            ImageProcessingProcessor ipp = new ImageProcessingProcessor(ProcessedImage, protocol);
            ipp.addPropertyChangeListener(this);    
            ipp.execute();
        
        }else{
            
            OriginalImage.deleteRoi();
            ProcessedImage = OriginalImage.duplicate();
            OriginalImage.restoreRoi();
            
            ImagePlus ProcessedShow = new ImagePlus("Processed");
            //ProcessedShow = UtilityMethods.makeThumbnail(ProcessedImage);
            ProcessedShow.setTitle(this.getName() + "_Processed");

            ProgressComment.setText("Processing complete...");
            ProcessedShow.show();
        }
        */
        /*if(ObjectStepsList.size() > 0){
            me.FolderDrawer.clear(); 
            me.ExploreDrawer.clear(); 

            notifyUpdatedImageListeners(ProcessedImage); 
        }*/
    }
/*
    private synchronized void executeObjectFinding() {

        this.PreProcessingGo.setEnabled(false);
        ProgressComment.setText("Finding objects...");
               
        ArrayList<ArrayList> protocol = new ArrayList<>();
        protocol = extractSteps(ObjectStepsList, OBJECTBLOCKS);

        System.out.println("PROFILING: From tab, '" + this.tabName + "' Found " + ObjectStepsList.size() + " object definitions to process.");
        me.start(ProcessedImage, protocol, true);
        
        this.exploreText.setForeground(new java.awt.Color(0, 0, 0));
        
        for(int i = 0; i < ObjectStepsList.size(); i++){
            if(((MicroFolder)me.FolderDrawer.get(i)).getAvailableData().size() > 0){
            executeExploring(i);
            ProgressComment.setText("Finding objects complete...");
            } else {
              ProgressComment.setText("No objects found...");  
            }
        } 
            VTEAProgressBar.setMaximum(255);
            VTEAProgressBar.setMinimum(0);
            VTEAProgressBar.setValue(0);
            ObjectGo.setEnabled(false);
        System.gc();
    }
*/
/*
    private void executeExploring(int i) {  
        System.out.println("PROFILING: Explorer setup for Object_" + i);
        System.out.println("PROFILING: Explorer getting " +  me.getFolderVolumes(i).size() + " volumes for Object_" + i);
        VTEAProgressBar.setMaximum(me.getFolderVolumes(i).size() + 100);
        me.addExplore(ProcessedImage,  "Object_" + (i+1), me.getFolderVolumes(i), me.getAvailableFolderData(i));
       
    }
    ;
*/
static public ArrayList extractSteps(ArrayList sb_al) {

        ArrayList<ArrayList> Result = new ArrayList<ArrayList>();

        //if (blocktype == PROCESSBLOCKS) {

        FeatureStepBlockGUI ppsb;

        /*ListIterator<Object> litr = sb_al.listIterator();
        while (litr.hasNext()) {
            ppsb = (FeatureStepBlockGUI) litr.next();
            if (!(ppsb.Comment.getText()).equals("New Image")) {
                Result.add(ppsb.getVariables());
            }
        }
        */

        FeatureStepBlockGUI osb;
        ListIterator<Object> litr = sb_al.listIterator();
        while (litr.hasNext()) {
            osb = (FeatureStepBlockGUI) litr.next();

            Result.add(osb.getVariables());
            System.out.println("OSB variables: " + Result);
        }

        return Result;
    }
/*
    public void setImage(ImagePlus imp, int tab) {
        if ((tab + 1) == this.tab && (FeatureStepsList.size() == 0)) {

            OriginalImage = imp.duplicate();
            OriginalImage.setOpenAsHyperStack(true);

            this.ThumbnailImage = UtilityMethods.makeThumbnail(imp.duplicate());

            Channels = new ArrayList<String>();
            for (int i = 0; i <= OriginalImage.getNChannels() - 1; i++) {
                Channels.add("Channel_" + i);
            }
            AddStep_Preprocessing.setEnabled(true);

            ProcessStepBlockGUI block = new ProcessStepBlockGUI(imp.getTitle(), "New Image", ImageBlockBackground, batch, ThumbnailImage, OriginalImage, this.Channels, ProtocolManagerMulti.PROCESS, ProcessingStepsList, getBlockPosition());

            PreProcessingStepsPanel.setLayout(PreProcessingLayout);
            PreProcessingStepsPanel.add(block.getPanel());
            PreProcessingStepsPanel.repaint();
            //pack();

            FeatureStepsList.add(block);

            if (FeatureStepsList.size() <= 4) {

                AddStep_Preprocessing.setEnabled(true);
            }
            if (FeatureStepsList.size() >= 5) {

                AddStep_Preprocessing.setEnabled(false);
            }
        } 
    }
*/
    private int getBlockPosition() {
        int position;
        if (FeatureStepsList.isEmpty()) {
            position = 1;
        } else {
            position = FeatureStepsList.size() + 1;
        }
        return position;
    }
/* 
    public void setSelectedTab(boolean b){
        this.selected = b;
    }
*/
    public void addListener(AnalysisStartListener listener) {
        listeners.add(listener);
    }

    private void notifyListeners(int i) {
        for (AnalysisStartListener listener : listeners) {
            listener.onStartButton(i);
        }
    }
        
    public void addUpdatedProtocolListener(UpdatedProtocolListener listener) {
        UpdatedProtocolListeners.add(listener);
    }

    private void notifyUpdatedProtcolListeners(ArrayList<ArrayList> al) {
        for (UpdatedProtocolListener listener : UpdatedProtocolListeners) {
            listener.protocolUpdated(al);
        }
    }
/*
    public void addRequestImageListener(RequestImageListener listener) {
        RequestImageListeners.add(listener);
    }

    private void notifyRequestImageListeners(int tab) {
        for (RequestImageListener listener : RequestImageListeners) {
            listener.onRequest(tab);
        }
    }
*/
/*
    public void addRepaintFeatureListener(RepaintFeatureListener listener) {
        RepaintFeatureListeners.add(listener);
    }

    private void notifyRepaintFeatureListeners() {
        for (RepaintFeatureListener listener : RepaintFeatureListeners) {
            listener.repaintFeature();
        }
    }
*/
    public void addUpdatedImageListener(UpdatedImageListener listener) {
        UpdatedImageListeners.add(listener);
    }

    private void notifyUpdatedImageListeners(ImagePlus imp) {
        for (UpdatedImageListener listener : UpdatedImageListeners) {
            listener.onUpdateImage(imp);
        }
    }
/*
    @Override
    public void onSelect(ImagePlus imp, int tab) {

        if (tab == tab && FeatureStepsList.size() == 0) {
            imp.deleteRoi();
            this.OriginalImage = imp;
            imp.restoreRoi();
            
            ThumbnailImage = imp.duplicate();

            //ThumbnailImage = UtilityMethods.makeThumbnail(ThumbnailImage);

            Channels = new ArrayList<String>();
            for (int i = 0; i <= OriginalImage.getNChannels() - 1; i++) {
                Channels.add("Channel_" + (i + 1));
            }

            AddStep.setEnabled(true);

            FeatureStepBlockGUI block = new FeatureStepBlockGUI(imp.getTitle(), "New Image", ImageBlockBackground, this.ThumbnailImage, this.OriginalImage, this.Channels, ProtocolManagerMulti.PROCESS, FeatureStepsList, getBlockPosition());
            block.addRebuildPanelListener(this);
            FeatureStepsPanel.setLayout(FeatureLayout);
            FeatureStepsPanel.add(block.getPanel());
            FeatureStepsPanel.repaint();
            //pack();

            FeatureStepsList.add(block);

            if (FeatureStepsList.size() <= 4) {

                AddStep.setEnabled(true);
            }
            if (FeatureStepsList.size() >= 5) {

                AddStep.setEnabled(false);
            }
        }
        //notifyRepaintTabListeners();
        DeleteAllSteps.setEnabled(true);
        AddStep.setEnabled(true);
        FeatureGo.setEnabled(true);
        
        ProgressComment.setText("Image loaded...");
    }
*/
};
